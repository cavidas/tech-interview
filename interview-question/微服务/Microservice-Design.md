链接：https://www.jianshu.com/p/97ced7ffe4f8
                      
# 微服务原理和软件工程，面向对象设计中的基本原理相通，体现如下：

1. 单一职责（Single Responsibility），一个服务应当承担尽可能单一的职责，服务应基于有界的上下文
    （bounded context，通常是边界清晰的业务领域）构建，服务理想应当只有一个变更的理由
    （类似Robert C. Martin讲的：A class should have only one reason to change），
    当一个服务承担过多职责，就会产生各种耦合性问题，需要进一步拆分使其尽可能职责单一化。
    https://bbs.huaweicloud.com/blogs/177259
2. 关注分离（Separation of Concerns），跨横切面逻辑，例如日志分析、监控、限流、安全等等，尽可能与具体的业务逻辑相互分离，
    让开发人员能专注于业务逻辑的开发，减轻他们的思考负担，这个也是有界上下文（bounded context）的一个体现。
3. 模块化（Modularity）和分而治之（Divide & Conquer），这个是解决复杂性问题的一般性方法，将大问题（如单块架构）大而化小（模块化和微服务化），然后分而治之。
单一职责、自治性、领域驱动设计

# 微服务的交互模式

1. 读者容错模式（Tolerant Reader）指微服务化中服务提供者和消费者之间如何对接口的改变进行容错
    * 从字面上来讲，消费者需要对提供者提供的功能进行兼容性设计，尤其对服务提供者返回的内容进行兼容，或者解决在服务提供者改变接口或者数据的格式的情况下，如何让服务消费者正常运行。
    * 因此，在服务消费者处理服务提供者返回的消息的过程中，需要对服务返回的消息进行过滤，只提取自己需要的内容，对多余或者未知的内容采取抛弃的策略，而不是硬生生地抛错处理。
    * e.g. 在服务接口的定义中，参数可以使用枚举值，在返回值的DTO中禁止使用枚举值。
    
2. 消费者驱动契约模式
    * 消费者驱动契约模式用来定义服务化中服务之间交互接口改变的最佳规则。
    * 服务契约分为：提供者契约、消费者契约及消费者驱动的契约，它从期望与约束的角度描述了服务提供者与服务消费者之间的联动关系。
        * 提供者契约：是我们最常用的一种服务契约，顾名思义，提供者契约是以提供者为中心的，提供者提供了什么功能和消息格式，各消费者都会无条件地遵守这些约定，不论消费者实际需要多少功能，消费者接受了提供者契约时，都会根据服务提供者的规则来使用服务。
        * 消费者契约：是对某个消费者的需求进行更为精确的描述，在一次具体的服务交互场景下，代表消费者需要提供者提供功能中的哪部分数据。消费者契约可以被用来标识现有的提供者契约，也可以用来发现一个尚未明确的提供者契约。
        * 消费者驱动的契约：代表服务提供者向其所有当前消费者承诺遵守的约束。一旦各消费者把自己的具体期望告知提供者，则提供者无论在什么时间和场景下，都不应该打破契约。
        
3. 去数据共享模式
    
微服务之间的交互通过定义良好的接口来实现，不允许使用共享数据来实现。

Bad Example: 
https://upload-images.jianshu.io/upload_images/6898826-e1621dcf13fe8113?imageMogr2/auto-orient/strip|imageView2/2/w/868/format/webp
这种交互流程的缺点如下。

    使得微服务之间的交互除了接口契约，还存在数据存储契约。
    上游的数据格式发生变化时，可能导致下游的处理逻辑出现问题。
    多个服务共享一个资源服务，对资源服务的运维难以划清职责和界限。
    在做双机房独立部署时，需要考虑服务和资源的路由情况，跨机房的服务调用不能使用独立的资源部署模式，因此难以实现服务自治。

因此，在设计微服务架构时，一定不要共享缓存和数据库等资源，也不要使用总线模式，服务之间的通信和交互只能依赖定义良好的接口，通常使用RESTful样式的API或者透明的RPC调用框架。


# 微服务的分解和组合模式
良好的划分和拆分使系统达到松耦合和高内聚的效果，然后通过微服务的灵活组装可以满足上层的各种各样的业务处理需求。

在微服务架构的需求分析和架构设计过程中，通常是用领域的**动词**和**名词**来划分微服务的，例如，对于一个电商后台系统，可以分解为订单、商品、商品目录、库存、购物车、交易、支付、发票、物流等子系统，每个名词和动词都可以是一个微服务，将这几个微服务组合在一起，就实现了电商平台用户购买商品的整个业务流。

## 以什么方式组合微服务呢？
1. 服务代理模式

    服务代理模式是最简单的服务组合模式，它根据业务的需求选择调用后端的某个服务。在返回给使用端之前，代理可以对后端服务的输出进行加工，也可以直接把后端服务的返回结果返回给使用端。
    
    在笔者工作的微服务化架构平台下，经常会使用这种模式，典型的案例是做平滑的系统迁移，通常经历如下4个阶段。
        
        在新老系统上双写。
        迁移双写之前的历史遗留数据。
        将读请求切换到新系统。
        下调双写逻辑，只写新系统。
    服务代理模式常常应用到第3步，一般会对读请求切换设计一个开关，开关打开时查询新系统，开关关闭时查询老系统。

2. 服务聚合模式
    服务聚合模式是最常用的服务组合模式，它根据业务流程处理的需要，以一定的顺序调用依赖的多个微服务，对依赖的微服务返回的数据进行组合、加工和转换，最后以一定的形式返回给使用方。
    
    这里，每个被依赖的微服务都有自己的缓存和数据库，聚合服务本身可以有自己的数据存储，包括缓存和数据库等，也可以是简单的聚合，不需要持久化任何数据。
    
    这里体现了DRY（Don’t Repeat Yourself）原则的设计理念，在设计或者构造应用时，最大限度地重用了现有的实现。
    
3. 服务串联模式
    服务串联模式类似于一个工作流，最前面的服务1负责接收请求和响应使用方，串联服务后再与服务1交互，随后服务1与服务2交互，最后，从服务2产生的结果经过服务1和串联服务逐个处理后返回给使用方
    https://upload-images.jianshu.io/upload_images/6898826-fb8b60d253026ae0?imageMogr2/auto-orient/strip|imageView2/2/w/553/format/webp
    
    服务串联模式之间的调用通常使用同步的RESTful风格的远程调用实现，
    注意，这种模式采用的是**同步调用方式**，在串联服务没有完成并返回之前，所有服务都会阻塞和等待，一个请求会占用一个线程来处理，因此在这种模式下不建议服务的层级太多，**如果能用服务聚合模式代替，则优先使用服务聚合模式**，而不是使用这种服务串联模式。
    
    服务串联模式有一个优点，即串联链路上再增加一个节点时，只要不是在串联服务的正后面增加，那么串联服务是无感知的
    
4. 服务分支模式
    
    服务分支模式是服务代理模式、服务聚合模式和服务串联模式相结合的产物。
   
    分支服务可以拥有自己的数据库存储，调用多个后端的服务或者服务串联链，然后将结果进行组合处理再返回给客户端。分支服务也可以使用代理模式，简单地调用后端的某个服务或者服务链，然后将返回的数据直接返回给使用方。
    
    较有趣的现象
    
    假设有一个基础服务，在服务分支模式的多个层次中对基础服务都有依赖，那么当基础服务的一台机器宕机时，假设基础服务有8台机器，则最后受影响的流量并不是1/8
    https://upload-images.jianshu.io/upload_images/6898826-85695ee11f4d1e67?imageMogr2/auto-orient/strip|imageView2/2/w/1040/format/webp
    
    假设基础服务资源池中的机器个数为i，一次挂掉的机器个数为j，一个调用链中调用x次基础服务，那么正确处理的流量的计算公式为：
    ((i-j)/i)^x 

    由于分支模式放大了服务的依赖关系，因此在现实的微服务设计中尽量保持服务调用级别的简单，在使用服务组合和服务代理模式时，不要使用服务串联模式和服务分支模式，以保持服务依赖关系的清晰明了，这也减少了日后维护的工作量。

5. 服务异步**消息模式**
    
    在构建微服务架构系统时，通常会梳理核心系统的最小化服务集合，这些核心的系统服务使用同步调用，而其他核心链路以外的服务可以使用异步消息队列进行异步化。
 
6. 服务共享数据模式
    服务共享数据模式其实是反模式，在1.3.3节中提出了去数据共享模式，由于去掉了数据共享，所以仅仅通过服务之间良好定义的接口进行交互和通信，使得每个服务都是自治的，服务本身和服务的团队包含全角色栈的技术和运营人员，这些人都是专业的人做专业的事，使沟通在团队内部解决，因此可以使效率最大化。
    然而，在下面两种场景下，我们仍然需要数据共享模式。
    
    * 单元化架构 
   
   一些平台由于对性能有较高的要求，所以采用微服务化将服务进行拆分，通过网络服务进行通信，
   尽管网络通信的带宽已经很宽，但是还会有性能方面的损耗，
   在这种场景下，**可以让不同的微服务共享一些资源**，例如：缓存、数据库等，
   甚至可以将缓存和数据在物理拓扑上与微服务部署在一个物理机中，最大限度地减少网络通信带来的性能损耗，我们将这种方法称为“**单元化架构**”。
   https://upload-images.jianshu.io/upload_images/6898826-a0a2b64b4126dbf7?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp
   
    * 遗留的整体服务 
    
    对于历史遗留的传统单体服务，我们在重构微服务的过程中，发现单体服务依赖的数据库表耦合在一起，
    对其拆分需要进行反规范化的处理，可能会造成数据一致性问题，
    在没有对其完全理解和有把握的前提下，会选择保持现状，让不同的微服务暂时共享数据存储。
    
**除了上面提到的两个场景，任何场景都不能使用服务数据共享模式。**


## 微服务的容错模式

由于服务与服务的调用不再是进程内的调用，而是通过网络进行的远程调用，
众所周知，网络通信是不稳定、不可靠的，
一个服务依赖的服务可能出错、超时或者宕机，如果没有及时发现和隔离问题，或者在设计中没有考虑如何应对这样的问题，
那么很可能在短时间内服务的线程池中的线程被用满、资源耗尽，导致出现雪崩效应。

1. 舱壁隔离模式
    这里用航船的设计比喻舱壁隔离模式，若一艘航船遇到了意外事故，其中一个船舱进了水，则我们希望这个船舱和其他船舱是隔离的，希望其他船舱可以不进水，不受影响。
    1. 微服务容器分组
    
        笔者所在的支付平台应用了微服务，将微服务的每个节点的服务池分为三组：
            准生产环境、灰度环境和生产环境。准生产环境供内侧使用；
        灰度环境会跑一些普通商户的流量；大部分生产流量和VIP商户的流量则跑在生产环境中。    
        这样，在一次比较大的重构过程中，我们就可以充分利用灰度环境的隔离性进行预验证，用普通商户的流量验证重构没有问题后，再上生产环境。
    2. 线程池隔离
        
        在微服务架构实施的过程中，我们不一定将每个服务拆分到微小的力度，这取决于职能团队和财务的状况，我们一般会将同一类功能划分在一个微服务中，尽量避免微服务过细而导致成本增加，适可而止。
        这样就会导致多个功能混合部署在一个微服务实例中，这些微服务的不同功能通常使用同一个线程池，导致一个功能流量增加时耗尽线程池的线程，而阻塞其他功能的服务。

2. 熔断模式
当服务的输入负载迅速增加时，如果没有有效的措施对负载进行熔断，则会使服务迅速被压垮。
服务被压垮会导致依赖的服务都被压垮，出现雪崩效应。
因此，可通过模拟家庭的电路保险开关，在微服务架构中实现熔断模式。
https://juejin.im/post/5c0ba2bef265da614d08fefe   
   
3. 限流模式
针对服务突然上量，我们必须有限流机制，限流机制一般会控制访问的并发量，例如每秒允许处理的并发用户数及查询量、请求量等。
有如下几种主流的方法实现限流:
    1. 计数器 
    通过原子变量计算单位时间内的访问次数，如果超出某个阈值，则拒绝后续的请求，等到下一个单位时间再重新计数。
    2. 令牌筒
    令牌筒是一个流行的实现限流的技术方案，它通过一个线程在单位时间内生产固定数量的令牌，然后把令牌放入队列，每次请求调用需要从桶中拿取一个令牌，拿到令牌后才有资格执行请求调用，否则只能等待拿到令牌再执行，或者直接丢弃。
    3. 信号量
    限流类似于生活中的漏洞，无论倒入多少油，下面有漏管的流量是有限的，实际上我们在应用层使用的信号量也可以实现限流。
     
4. 失效转移模式
若微服务架构中发生了熔断和限流，则该如何处理被拒绝的请求呢？
解决这个问题的模式叫作失效转移模式，通常分为下面几种:
    1. 采用快速失败的策略，直接返回使用方错误，让使用方知道发生了问题并自行决定后续处理。
       
    2. 是否有备份服务，如果有备份服务，则迅速切换到备份服务。
       
       失败的服务有可能是某台机器有问题，而不是所有机器有问题，例如OOM问题，在这种情况下适合使用failover策略，采用重试的方法来解决，但是这种方法要求服务提供者的服务实现了幂等性。
       

# 微服务的粒度
在服务化系统或者微服务架构中，我们如何拆分服务才是最合理的？服务拆分到什么样的粒度最合适？

按照微服务的初衷，服务要按照业务的功能进行拆分，直到每个服务的功能和职责单一，甚至不可再拆分为止，以至于每个服务都能独立部署，扩容和缩容方便，能够有效地提高利用率。拆得越细，服务的耦合度越小，内聚性越好，越适合敏捷发布和上线。

然而，拆得太细会导致系统的服务数量较多，相互依赖的关系较复杂，更重要的是根据康威定律，团队要响应系统的架构，每个微服务都要有相应的独立、自治的团队来维护，这也是一个不切实际的想法。

因此，这里倡导对微服务的拆分适可而止，原则是拆分到可以让使用方自由地编排底层的子服务来获得相应的组合服务即可，同时要考虑团队的建设及人员的数量和分配等。

总之，拆分的粒度太细和太粗都是不合理的，根据业务需要，能够满足上层服务对底层服务自由编排并获得更多的业务功能即可，并需要适合团队的建设和布局。


优点
    
    优点每个服务足够内聚，足够小，代码容易理解这样能聚焦一个指定的业务功能或业务需求
    
    开发简单、开发效率提高，一个服务可能就是专一的只干一件事。
    
    微服务能够被小团队单独开发，这个小团队是 2 到 5 人的开发人员组成。
    
    微服务是松藕合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。
    
    微服务能使用不同的语言开发。
    
    易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins,Hudson,bamboo。
    
    微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需- - 通过合作才能体现价值。微服务允许你利用融合最新技术。
    
    微服务只是业务逻辑的代码，不会和 HTML,CSS或其他界面组件混合。
    
    每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。
 
 技术异构更容易，新技术应用更自由，架构与组织架构相互促进相互优化，更好的建设和锻炼团队，扩展容易，部署简单（更新和回滚），高重用性，高弹性，替换陈旧组件更容易等等。
缺点
    分布式环境下的数据一致性，测试的复杂性，运维的复杂性。
    
    
传统的团队，都是面向过程化的，产品想完了去找策划，策划完了找开发，接着顺着一步一步找。我们做技术都是为了产品的，一旦过程出来了什么问题，回溯寻找问题会非常耗时

使用了微服务架构体系，团队组织方式需要转变成跨职能团队，即每个团队都有产品专家，策划专家，开发专家，运维专家，他们使用API方式发布他们的功能，而平台使用他们的功能发布产品
https://user-gold-cdn.xitu.io/2018/12/8/1678d75936dac9a1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1
https://user-gold-cdn.xitu.io/2018/12/8/1678d75eacf4feee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1



# Governance
https://juejin.im/post/5cde86d66fb9a07ed5246db0
https://www.infoq.cn/article/BVITbB8kOGSjK2GimDLW

To do:
你对服务治理怎么理解的？
项目中的限流怎么实现的？
具体怎么实现的？
如果突然很多线程同时请求令牌，有什么问题？
怎么解决呢？
如果不用消息队列怎么解决？